"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const tools_1 = require("../../tools");
const readonly_1 = __importDefault(require("../../readonly"));
const logger_1 = __importDefault(require("../../logger"));
const handlers_1 = __importDefault(require("./handlers"));
const utils_1 = require("../../utils");
class DirectoryContext {
    constructor(config, mgmtClient) {
        this.filePath = config.AUTH0_INPUT_FILE;
        this.config = config;
        this.mappings = config.AUTH0_KEYWORD_REPLACE_MAPPINGS || {};
        this.mgmtClient = mgmtClient;
        //@ts-ignore for now
        this.assets = {};
        // Get excluded rules
        this.assets.exclude = {
            rules: config.AUTH0_EXCLUDED_RULES || [],
            clients: config.AUTH0_EXCLUDED_CLIENTS || [],
            databases: config.AUTH0_EXCLUDED_DATABASES || [],
            connections: config.AUTH0_EXCLUDED_CONNECTIONS || [],
            resourceServers: config.AUTH0_EXCLUDED_RESOURCE_SERVERS || [],
            defaults: config.AUTH0_EXCLUDED_DEFAULTS || [],
        };
    }
    loadFile(f, folder) {
        const basePath = path.join(this.filePath, folder);
        let toLoad = path.join(basePath, f);
        if (!(0, utils_1.isFile)(toLoad)) {
            // try load not relative to yaml file
            toLoad = f;
        }
        return (0, tools_1.loadFileAndReplaceKeywords)(toLoad, this.mappings);
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, utils_1.isDirectory)(this.filePath)) {
                /* If this is a directory, look for each file in the directory */
                logger_1.default.info(`Processing directory ${this.filePath}`);
                Object.entries(handlers_1.default)
                    .filter(([handlerName]) => {
                    const excludedAssetTypes = this.config.AUTH0_EXCLUDED || [];
                    return !excludedAssetTypes.includes(handlerName);
                })
                    .forEach(([_name, handler]) => {
                    const parsed = handler.parse(this);
                    Object.entries(parsed).forEach(([k, v]) => {
                        this.assets[k] = v;
                    });
                });
                return;
            }
            throw new Error(`Not sure what to do with, ${this.filePath} as it is not a directory...`);
        });
    }
    dump() {
        return __awaiter(this, void 0, void 0, function* () {
            const auth0 = new tools_1.Auth0(this.mgmtClient, this.assets, (0, utils_1.toConfigFn)(this.config));
            logger_1.default.info('Loading Auth0 Tenant Data');
            yield auth0.loadAll();
            this.assets = auth0.assets;
            // Clean known read only fields
            this.assets = (0, readonly_1.default)(this.assets, this.config);
            // Copy clients to be used by handlers which require converting client_id to the name
            // Must copy as the client_id will be stripped if AUTH0_EXPORT_IDENTIFIERS is false
            //@ts-ignore because assets haven't been typed yet TODO: type assets
            this.assets.clientsOrig = [...(this.assets.clients || [])];
            // Optionally Strip identifiers
            if (!this.config.AUTH0_EXPORT_IDENTIFIERS) {
                this.assets = (0, utils_1.stripIdentifiers)(auth0, this.assets);
            }
            yield Promise.all(Object.entries(handlers_1.default)
                .filter(([handlerName]) => {
                const excludedAssetTypes = this.config.AUTH0_EXCLUDED || [];
                return !excludedAssetTypes.includes(handlerName);
            })
                .map(([name, handler]) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield handler.dump(this);
                }
                catch (err) {
                    logger_1.default.debug(err.stack);
                    throw new Error(`Problem exporting ${name}`);
                }
            })));
        });
    }
}
exports.default = DirectoryContext;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const path_1 = __importDefault(require("path"));
const tools_1 = require("../../tools");
const logger_1 = __importDefault(require("../../logger"));
const utils_1 = require("../../utils");
const handlers_1 = __importDefault(require("./handlers"));
const readonly_1 = __importDefault(require("../../readonly"));
class YAMLContext {
    constructor(config, mgmtClient) {
        this.configFile = config.AUTH0_INPUT_FILE;
        this.config = config;
        this.mappings = config.AUTH0_KEYWORD_REPLACE_MAPPINGS || {};
        this.mgmtClient = mgmtClient;
        //@ts-ignore because the assets property gets filled out throughout
        this.assets = {};
        // Get excluded rules
        this.assets.exclude = {
            rules: config.AUTH0_EXCLUDED_RULES || [],
            clients: config.AUTH0_EXCLUDED_CLIENTS || [],
            databases: config.AUTH0_EXCLUDED_DATABASES || [],
            connections: config.AUTH0_EXCLUDED_CONNECTIONS || [],
            resourceServers: config.AUTH0_EXCLUDED_RESOURCE_SERVERS || [],
            defaults: config.AUTH0_EXCLUDED_DEFAULTS || [],
        };
        this.basePath = (() => {
            if (!!config.AUTH0_BASE_PATH)
                return config.AUTH0_BASE_PATH;
            //@ts-ignore because this looks to be a bug, but do not want to introduce regression; more investigation needed
            return typeof configFile === 'object' ? process.cwd() : path_1.default.dirname(this.configFile);
        })();
    }
    loadFile(f) {
        let toLoad = path_1.default.join(this.basePath, f);
        if (!(0, utils_1.isFile)(toLoad)) {
            // try load not relative to yaml file
            toLoad = f;
        }
        return (0, tools_1.loadFileAndReplaceKeywords)(path_1.default.resolve(toLoad), this.mappings);
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            // Allow to send object/json directly
            if (typeof this.configFile === 'object') {
                this.assets = this.configFile;
            }
            else {
                try {
                    const fPath = path_1.default.resolve(this.configFile);
                    logger_1.default.debug(`Loading YAML from ${fPath}`);
                    Object.assign(this.assets, js_yaml_1.default.load((0, tools_1.keywordReplace)(fs_extra_1.default.readFileSync(fPath, 'utf8'), this.mappings)) || {});
                }
                catch (err) {
                    logger_1.default.debug(err.stack);
                    throw new Error(`Problem loading ${this.configFile}\n${err}`);
                }
            }
            const excludedAssetsFiltered = Object.keys(this.assets).reduce((acc, key) => {
                const excludedAssetTypes = this.config.AUTH0_EXCLUDED || [];
                if (excludedAssetTypes.includes(key))
                    return acc;
                return Object.assign(Object.assign({}, acc), { [key]: this.assets[key] });
            }, {});
            this.assets = excludedAssetsFiltered;
            // Run initial schema check to ensure valid YAML
            const auth0 = new tools_1.Auth0(this.mgmtClient, this.assets, (0, utils_1.toConfigFn)(this.config));
            yield auth0.validate();
            // Allow handlers to process the assets such as loading files etc
            yield Promise.all(Object.entries(handlers_1.default).map(([name, handler]) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const parsed = yield handler.parse(this);
                    Object.entries(parsed).forEach(([k, v]) => {
                        this.assets[k] = v;
                    });
                }
                catch (err) {
                    logger_1.default.debug(err.stack);
                    throw new Error(`Problem deploying ${name}`);
                }
            })));
        });
    }
    dump() {
        return __awaiter(this, void 0, void 0, function* () {
            const auth0 = new tools_1.Auth0(this.mgmtClient, this.assets, (0, utils_1.toConfigFn)(this.config));
            logger_1.default.info('Loading Auth0 Tenant Data');
            try {
                yield auth0.loadAll();
                this.assets = auth0.assets;
            }
            catch (err) {
                const docUrl = 'https://auth0.com/docs/deploy/deploy-cli-tool/create-and-configure-the-deploy-cli-application#modify-deploy-cli-application-scopes';
                const extraMessage = err.message.startsWith('Insufficient scope')
                    ? `\nSee ${docUrl} for more information`
                    : '';
                throw new Error(`Problem loading tenant data from Auth0 ${err}${extraMessage}`);
            }
            yield Promise.all(Object.entries(handlers_1.default)
                .filter(([handlerName]) => {
                const excludedAssetTypes = this.config.AUTH0_EXCLUDED || [];
                return !excludedAssetTypes.includes(handlerName);
            })
                .map(([name, handler]) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const data = yield handler.dump(this);
                    if (data) {
                        if (data[name] !== null)
                            logger_1.default.info(`Exporting ${name}`);
                        Object.entries(data).forEach(([k, v]) => {
                            this.assets[k] = Array.isArray(v)
                                ? v.map(utils_1.formatResults).sort(utils_1.recordsSorter)
                                : (0, utils_1.formatResults)(v);
                        });
                    }
                }
                catch (err) {
                    logger_1.default.debug(err.stack);
                    throw new Error(`Problem exporting ${name}`);
                }
            })));
            // Clean known read only fields
            let cleaned = (0, readonly_1.default)(this.assets, this.config);
            // Delete exclude as it's not part of the auth0 tenant config
            delete cleaned.exclude;
            // Optionally Strip identifiers
            if (!this.config.AUTH0_EXPORT_IDENTIFIERS) {
                cleaned = (0, utils_1.stripIdentifiers)(auth0, cleaned);
            }
            // Write YAML File
            const raw = js_yaml_1.default.dump(cleaned);
            logger_1.default.info(`Writing ${this.configFile}`);
            fs_extra_1.default.writeFileSync(this.configFile, raw);
        });
    }
}
exports.default = YAMLContext;

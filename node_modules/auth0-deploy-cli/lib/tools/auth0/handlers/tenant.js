"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitizeMigrationFlags = exports.schema = void 0;
const validationError_1 = __importDefault(require("../../validationError"));
const default_1 = __importStar(require("./default"));
const pages_1 = require("./pages");
const utils_1 = require("../../utils");
exports.schema = {
    type: 'object',
};
const blockPageKeys = [
    ...Object.keys(pages_1.pageNameMap),
    ...Object.values(pages_1.pageNameMap),
    ...pages_1.supportedPages,
];
class TenantHandler extends default_1.default {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { type: 'tenant' }));
    }
    getType() {
        return __awaiter(this, void 0, void 0, function* () {
            const tenant = yield this.client.tenant.getSettings();
            this.existing = tenant;
            blockPageKeys.forEach((key) => {
                if (tenant[key])
                    delete tenant[key];
            });
            return tenant;
        });
    }
    validate(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tenant } = assets;
            // Nothing to validate?
            if (!tenant)
                return;
            const pageKeys = Object.keys(tenant).filter((k) => blockPageKeys.includes(k));
            if (pageKeys.length > 0) {
                throw new validationError_1.default(`The following pages ${(0, utils_1.convertJsonToString)(pageKeys)} were found in tenant settings. Pages should be set separately. Please refer to the documentation.`);
            }
        });
    }
    // Run after other updates so objected can be referenced such as default directory
    processChanges(assets) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tenant } = assets;
            // Do nothing if not set
            if (!tenant)
                return;
            const existingTenant = this.existing || (yield this.getType());
            const updatedTenant = Object.assign(Object.assign({}, tenant), { flags: (0, exports.sanitizeMigrationFlags)({
                    existingFlags: existingTenant.flags,
                    proposedFlags: tenant.flags,
                }) });
            if (updatedTenant && Object.keys(updatedTenant).length > 0) {
                yield this.client.tenant.updateSettings(updatedTenant);
                this.updated += 1;
                this.didUpdate(updatedTenant);
            }
        });
    }
}
__decorate([
    (0, default_1.order)('100')
], TenantHandler.prototype, "processChanges", null);
exports.default = TenantHandler;
const sanitizeMigrationFlags = ({ existingFlags = {}, proposedFlags = {}, }) => {
    /*
    Tenants can only update migration flags that are already configured.
    If moving configuration from one tenant to another, there may be instances
    where different migration flags exist and cause an error on update. This
    function removes any migration flags that aren't already present on the target
    tenant. See: https://github.com/auth0/auth0-deploy-cli/issues/374
    */
    const tenantMigrationFlags = [
        'disable_clickjack_protection_headers',
        'enable_mgmt_api_v1',
        'trust_azure_adfs_email_verified_connection_property',
        'include_email_in_reset_pwd_redirect',
        'include_email_in_verify_email_redirect',
    ];
    return Object.keys(proposedFlags).reduce((acc, proposedKey) => {
        const isMigrationFlag = tenantMigrationFlags.includes(proposedKey);
        if (!isMigrationFlag)
            return Object.assign(Object.assign({}, acc), { [proposedKey]: proposedFlags[proposedKey] });
        const keyCurrentlyExists = existingFlags[proposedKey] !== undefined;
        if (keyCurrentlyExists)
            return Object.assign(Object.assign({}, acc), { [proposedKey]: proposedFlags[proposedKey] });
        return acc;
    }, {});
};
exports.sanitizeMigrationFlags = sanitizeMigrationFlags;
